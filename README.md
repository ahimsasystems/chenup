# chenup

chenup is a new Java persistence library that addresses many limitations of existing ORM tools and libraries by returning to the E-R model as originally defined by Peter Chen in his classic paper from 1976, "The Entity-Relationship Model: Toward a Unified View of Data. In addition, it takes advantage of contemporary Java features to make it easier to use, automatically compatible with IDEs, and more adherent to the E-R model.

In particular, note the following:
* Instead of enhancing classes or using proxies, all coding is done using interfaces and the implementations are generated at compile time through an annotation processor, in a manner similar to google's AutoValue.
* Implementations can be generated both with relational databases and with non-relational databases. The initial target is PostgreSQL, with FoundationDB (which is an advanced key-value store that supports ACID transactions) as the next target. The goal is to be able to use the same code with both types of databases and to be able to switch between them without changing the user code. Postgres is used because of its close approximation to the original E-R model and includes support for user-defined types (UDTs) and arrays, which are not available in most other databases. FoundationDB is used because it is a modern key-value store that supports ACID transactions and has a very flexible data model.
* Relationships are first-class citizens, on an equal footing with Entities. This allows relationships to have their own attributes and lifecycle. Convenience methods can mimic the direct access to other objects in JPA, but it is important to understand that all such navigation is through intervening relationships.
* Entities contain only attributes and no direct references to other entities. However, they can contain user-defined types, which are not entities, and which are mapped directly to UDTs in the database. At present, this mapping is restricted to PostgreSQL. The next target will be FoundationDB, where the objects will be serialized most probably using protobuf.
* Business logic can be contained in the interfaces through the use of default methods, which became available starting with Java 8. Default methods mean the business logic can be contained in stable interfaces and will not be overwritten. This obviates the need for patterns such as Generation Gap, which were formerly used, or the increasing practice of moving this code into a service layer.
* Because the implementation is generated by the annotation processor, there is no need to enhance classes or use proxies. This allows for efficient implementation of several features, including the ability to determine whether an object is dirty without the need for a diff with the initial state, as is typical with Hibernate.
* The system uses no reflection, meaning that debugging and stack traces are much easier to read and the code can be pre-compiled, for example, using GraalVM.
* As per best practices, the entity IDs are neither created by the user nor directly available through the normal interface. Instead, they are generated by the database as UUIDv7 surrogate keys.
* However, by extending the PersistenceCapable interface, application code can directly access some of the persistence machinery, including the entity ID, the entity state including whether it is dirty, etc. This avoids the need to recast the object to a specific implementation class to access these details.
* The intent is for chenup to be usable in any modern Java application, including Jakarta EE, Spring, and microprofile. However, there is absolutely no intent to integrate it with of the existing ORM management tools.
* Unlike permazen, no assumption is made that the database is accessed only from Java.
* There are no nulls. In relationships, nulls are not needed because it is simply that the row is deleted. For conveninece functions, like getEmployer(), at first this will always be expected to return a collection, which may be empty. We will see how well this wears in practice. The intent is to avoid nulls as much as possible, but this may be too restrictive in some cases.

A non-goal was direct compatibility with any existing ORM tool or library, or any standard such as JPA. The annotations used in some cases match the names of annotations from JPA or JDO, but the semantics are generally different.