# chenup

## Brief Overview
chenup is a new Java persistence library that addresses many limitations of existing ORM tools and libraries by returning to the E-R model as originally defined by Peter Chen in his classic paper from 1976, "The Entity-Relationship Model: Toward a Unified View of Data". In addition, it takes advantage of contemporary Java features to make it easier to use, automatically compatible with IDEs, and more adherent to the E-R model.

From a conceptual modeling perspective, chenup extends the conceptual model of JPA to allow for relationships to be first-class citizens, on an equal footing with entities, and formalizes the representation of attribute types as value types, including the standard built-in types like the numeric types, String, Date, etc., which are mapped very much like JPA into the database. However, it also allows for the use of record types as value types, which map very naturally to user-defined types in, for example, Postgres. References to other entities are not allowed in entities, but instead are represented as relationships. Like entities, relationships have their own attributes and lifecycle. The first release of chunup will support only binary relationships, but the intent is to support n-ary relationships in the future. 

From a software engineering perspective, chenup's innovation over JPA is to use Java interfaces to provide the definition of the E-R model, taking advantage of  default methods in interfaces to allow business logic to be written directly in the interfaces instead of being in concrete classes or shifted to service layers. All coding is done using interfaces, and the implementations are generated at compile time through an annotation processor, in a manner similar to google's AutoValue. This avoids the need for bytecode enhancement, reflection, and proxies, which are common in existing ORM tools, and the resulting code is fully compatible with Java IDEs without any need for special configuration.

One goal of chenup is to be fully reversible, that is, a database designed with the same constraints and standards should be able to be fully reversed into the Java code, minus, of course, the business logic in the interfaces. This means honoring the database as much as the java code, including having proper database constraints. This means that the database can be directly updated by other applications. An example of this would be a 1-to-many relationship, which can be enforced in the database by making the left side foreign key the primary key while leaving the right-hand foreign key unconstrained.

* Implementations can be generated both with relational databases and with non-relational databases. The initial target is PostgreSQL, with FoundationDB (which is an advanced key-value store that supports ACID transactions) as the next target. The goal is to be able to use the same code with both types of databases and to be able to switch between them without changing the user code. Postgres is used because of its close approximation to the original E-R model and includes support for user-defined types (UDTs) and arrays, which are not available in most other databases. FoundationDB is used because it is a modern key-value store that supports ACID transactions and has a very flexible data model.
* Relationships are first-class citizens, on an equal footing with Entities. This allows relationships to have their own attributes and lifecycle. Convenience methods can mimic the direct access to other objects in JPA, but it is important to understand that all such navigation is through intervening relationships.
* Entities contain only attributes and no direct references to other entities. However, they can contain user-defined types, which are not entities, and which are mapped directly to UDTs in the database. At present, this mapping is restricted to PostgreSQL. The next target will be FoundationDB, where the objects will be serialized, most probably using protobuf.
* Business logic can be contained in the interfaces through the use of default methods, which became available starting with Java 8. Default methods mean the business logic can be contained in stable interfaces and will not be overwritten. This obviates the need for patterns such as Generation Gap, which were formerly used, or the increasing practice of moving this code into a service layer.
* Because the implementation is generated by the annotation processor, there is no need to enhance classes or use proxies. This allows for efficient implementation of several features, including the ability to determine whether an object is dirty without the need for a diff with the initial state, as is typical with Hibernate.
* The system uses no reflection, meaning that debugging and stack traces are much easier to read and the code can be pre-compiled, for example, using GraalVM.
* ~~As per best practices, the entity IDs are neither created by the user nor directly available through the normal interface. Instead, they are generated by the database as UUIDv7 surrogate keys.~~
* ~~However, by extending the PersistenceCapable interface, application code can directly access some of the persistence machinery, including the entity ID, the entity state including whether it is dirty, etc. This avoids the need to recast the object to a specific implementation class to access these details.~~
* The ID of an Entity or a Relationship is not hidden. Surrogate keys can be directly accessed by the user. For the purposes of the user, this ID should be viewed as an opaque string. This accomplishes several things:
  * A user can use whatever means necessary to ascertain the correct ID, and then use that ID.
  * Different systems may chose to use the same ID if it is meant to represent the same real-world object.
  * There is no longer a need to find a query for entry into a system to get back to an Entity or Relationships that was previously discovered.* The intent is for chenup to be usable in any modern Java application, including Jakarta EE, Spring, and microprofile. However, there is absolutely no intent to integrate it with any of the existing ORM management tools, including 
* Unlike permazen, no assumption is made that the database is accessed only from Java.
* There are no nulls. In relationships, nulls are not needed because it is simply that the row is deleted. For conveninece functions, like getEmployer(), at first this will always be expected to return a collection, which may be empty. We will see how well this wears in practice. The intent is to avoid nulls as much as possible, but this may be too restrictive in some cases.


Future capabilities may include the following:
* The database is bi-temporal. This feature can be ignored if not needed, but it is available for those who need it.
* We can model union types using a combination of the @Union annotation and sealed interfaces. Correct SQL constraints will be generated.
* The ability to replace various parts of the implementaton with custom plugins, including the user's desired key generation algorithm.
* The ability for a user to provide their own key. Just as a note, this probably will need to be a key to a key so that the internal UUIDv7 key structure is preserved.

A non-goal was direct compatibility with any existing ORM tool or library, or any standard such as JPA. The annotations used in some cases match the names of annotations from JPA or JDO, but the semantics are generally different.

## Usage

If you are generating the code, you must include the following:

In your pom.xml:
  
```
<repositories>
<repository>
<id>github</id>
<url>https://maven.pkg.github.com/stephenwstrom/chenup</url>
<releases><enabled>true</enabled></releases>
<snapshots><enabled>true</enabled></snapshots>
</repository>
</repositories>


    <distributionManagement>
        <repository>
            <id>github</id>
            <url>https://maven.pkg.github.com/stephenwstrom/chenup</url>
        </repository>
        <snapshotRepository>
            <id>github</id>
            <url>https://maven.pkg.github.com/stephenwstrom/chenup</url>
        </snapshotRepository>
    </distributionManagement>

```

And configuration to the compiler plugin:

```
            <plugin>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${compiler-plugin.version}</version>
                <configuration>
                    <parameters>true</parameters>
                    <release>24</release>
                    <generatedSourcesDirectory>target/generated-sources/annotations</generatedSourcesDirectory>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>com.ahimsasystems</groupId>
                            <artifactId>chenup</artifactId>
                            <version>0.1-SNAPSHOT</version>
                        </path>
                    </annotationProcessorPaths>

                </configuration>
            </plugin>
            
            


```

And in src/main/resources/META-INF.services, create a file named `javax.annotation.processing.Processor` with the following content:

```
com.ahimsasystems.chenup.processor.EntityProcessor
```

*   
